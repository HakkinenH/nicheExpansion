## Basis of PCA ENV Method from Broenniman et al. April 2012.

##### Modified by Regan Early 2015
##### Further Modified by Hakkinen 2016

##
## DESCRIPTION
##
## functions to perform measures of niche overlap and niche equivalency/similarity tests as described in Broennimann et al. (submitted)
## 
## list of functions:
##
## grid.clim(glob,glob1,sp,R,th.sp,th.env) 
## use the scores of an ordination (or SDM predictions) and create a grid z of RxR pixels 
## (or a vector of R pixels when using scores of dimension 1 or SDM predictions) with occurrence densities
## Only scores of one, or two dimensions can be used 
## sp= scores for the occurrences of the species in the ordination, glob = scores for the whole studies areas, glob 1 = scores for the range of sp 
## R= resolution of the grid, th.sp=quantile of species densitie at species occurences used as a threshold to exclude low species density values, 
## th.env=quantile of environmental densitie at all study sites used as a threshold to exclude low environmental density values
##
## niche.overlap(z1,z2,cor)
## calculate the overlap metrics D and I (see Warren et al 2008) based on two species occurrence density grids z1 and z2 created by grid.clim
## cor=T correct occurrence densities of each species by the prevalence of the environments in their range
##
## plot.niche(z,title,name.axis1,name.axis2)
## plot a niche z created by grid.clim. title,name.axis1 and name.axis2 are strings for the legend of the plot
##
## plot.contrib(contrib,eigen)
## plot the contribution of the initial variables to the analysis. Typically the eigen vectors and eigen values in ordinations
##
## dynamic.index(z1,z2,intersection=NA)
## calculate niche expansion, stability and unfilling
## z1 : gridclim object for the native distribution
## z2 : gridclim object for the invaded range
## intersection : quantile of the environmental density used to remove marginal climates. 
## If intersection = NA, analysis is performed on the whole environmental extent (native and invaded)
## If intersection = 0, analysis is performed at the intersection between native and invaded range
## If intersection = 0.05, analysis is performed at the intersection of the 5th quantile of both native and invaded environmental densities 
## etc...
##
## plot.niche.dyn(z1,z2,quant,title,interest,colz1,colz2,colinter,colZ1=,colZ2=)
## plot niche categories and species density
## z1 : gridclim object for the native distribution
## z2 : gridclim object for the invaded range
## quant : quantile of the environmental density used to remove marginal climates.
## title : title of the figure
## interest : choose which density to plot. If interest=1 plot native density, if interest=2 plot invasive density
## colz1 : color used to depict unfilling area
## colz2 : color used to depict expansion area
## colinter : color used to depict overlap area
## colZ1 : color used to delimit the native extent
## colZ2 : color used to delimit the invaded extent
##
## pts2img <- function(pts,extent)
## convert plots into image
## pts = points coordinates (2 columns)
## extent : grid intervals (2 columns)
##
## fun.arrows(sp1,sp2,clim1,clim2)
## draw arrows linking the centroid of the native and inasive distribution (continuous line) and between native and invaded extent (dashed line)
## sp1 : scores of the species native distribution along the the 2 first axes of the PCA
## sp2 : scores of the species invasive distribution along the the 2 first axes of the PCA
## clim1 : scores of the entire native extent along the the 2 first axes of the PCA
## clim2 : scores of the entire invaded extent along the the 2 first axes of the PCA


##################################################################################################

grid.clim<-function(glob,glob1,sp,R,th.sp=0,th.env=0){
  
  l<-list()
  glob<-as.matrix(glob);glob1<-as.matrix(glob1);sp<-as.matrix(sp)
  if (ncol(glob)>2) stop("cannot calculate overlap with more than two axes")
  
  if(ncol(glob)==1){ 											#if scores in one dimension (e.g. LDA,SDM predictions,...)
    xmax<-max(glob[,1])
    xmin<-min(glob[,1])
    sp.dens<-density(sp[,1],kernel="gaussian",from=xmin,to=xmax,n=R,cut=0) 		# calculate the density of occurrences in a vector of R pixels along the score gradient
    # using a gaussian kernel density function, with R bins.
    glob1.dens<-density(glob1[,1],kernel="gaussian",from=xmin,to=xmax,n=R,cut=0)	# calculate the density of environments in glob1
    x<-sp.dens$x 											# breaks on score gradient
    z<-sp.dens$y*nrow(sp)/sum(sp.dens$y) 							# rescale density to the number of occurrences in sp
    # number of occurrence/pixel
    Z<-glob1.dens$y*nrow(glob)/sum(glob1.dens$y) 						# rescale density to the number of sites in glob1
    glob1r<-count(x,glob1);th.env<-min(Z[which(glob1r>0)]);glob1rm<-which(Z<th.env)
    spr<-count(x,sp);th.sp<-min(z[which(spr>0)]);sprm<-which(z<th.sp)
    z[sprm]<-0 										# remove infinitesimally small number generated by kernel density function
    Z[glob1rm]<-0 										# remove infinitesimally small number generated by kernel density function
    
    z.uncor<-z/max(z)											# rescale between [0:1] for comparison with other species
    z<-z/Z												# correct for environment prevalence
    z[is.na(z)]<-0 											# remove n/0 situations
    z[z=="Inf"]<-0 											# remove 0/0 situations
    z.cor<-z/max(z)											# rescale between [0:1] for comparison with other species
    w<-z
    w[w>0]<-1
    l$x<-x;l$z.uncor<-z.uncor;l$z.cor<-z.cor;l$Z<-Z;l$glob<-glob;l$glob1<-glob1;l$sp<-sp;l$w<-w
  }
  
  if(ncol(glob)==2){ #if scores in two dimensions (e.g. PCA)
    
    
    library(adehabitatHR)
    library(adehabitatLT)
    library(adehabitatMA)
    xmin<-min(glob[,1]);xmax<-max(glob[,1]);ymin<-min(glob[,2]);ymax<-max(glob[,2])			# data preparation
    glob1r<-data.frame(cbind((glob1[,1]-xmin)/abs(xmax-xmin),(glob1[,2]-ymin)/abs(ymax-ymin)))	# data preparation
    spr<-data.frame(cbind((sp[,1]-xmin)/abs(xmax-xmin),(sp[,2]-ymin)/abs(ymax-ymin))) 			# data preparation
    mask<-ascgen(cbind((1:R)/R,(1:R)/R),nrcol=R,count=F)								# data preparation
    sp.dens<-kernelUD(spr[,1:2],h = "href", grid=mask,kern="bivnorm")					# calculate the density of occurrences in a grid of RxR pixels along the score gradients
    
    # using a gaussian kernel density function, with RxR bins.
    sp.dens<-asc2spixdf(sp.dens[[1]]$UD)							# data manipulation
    #sp.dens$var[sp.dens$var>0 & sp.dens$var<1]<-0
    glob1.dens<-kernelUD(glob1r[,1:2],grid=mask,kern="bivnorm")
    glob1.dens<-asc2spixdf(glob1.dens[[1]]$UD)
    #glob1.dens$var[glob1.dens$var<1 & glob1.dens$var>0]<-0
    x<-seq(from=min(glob[,1]),to=max(glob[,1]),length.out=R)				# breaks on score gradient 1
    y<-seq(from=min(glob[,2]),to=max(glob[,2]),length.out=R)				# breaks on score gradient 2
    ###***### Here can see which gridcell ends up in.
    z<-matrix(sp.dens$var*nrow(sp)/sum(sp.dens$var),nrow=R,ncol=R,byrow=F) 			#rescale density to the number of occurrences in sp
    Z<-matrix(glob1.dens$var*nrow(glob1)/sum(glob1.dens$var),nrow=R,ncol=R,byrow=F) 	#rescale density to the number of sites in glob1
    spr<-pts2img(sp,cbind(x,y))
    glob1r<-pts2img(glob1,cbind(x,y))
    z.th<-quantile(as.vector(z[which(spr==1)]),th.sp)
    Z.th<-quantile(as.vector(Z[which(glob1r[]==1)]),th.env)  
    z[z<z.th]<-0 					#z[z<max(z)/(nrow(sp)/6)]<-0 or z[z<(nrow(sp)^(1/6)*0.005)]<-0 				# remove infinitesimally small number generated by kernel density function
    Z[Z<Z.th]<-0     # [Z<(nrow(glob1)^(1/6)*0.005)]
    z.uncor<-z/max(z)											# rescale between [0:1] for comparison with other species  
    w<-z.uncor 											# remove infinitesimally small number generated by kernel density function
    w[w>0]<-1
    z<-z/Z												# correct for environment prevalence
    z[is.na(z)]<-0											# remove n/0 situations
    z[z=="Inf"]<-0            	# remove n/0 situations
    z.cor<-z/max(z)											# rescale between [0:1] for comparison with other species
    l$x<-x;l$y<-y;l$z.uncor<-z.uncor;l$z.cor<-z.cor;l$Z<-Z;l$glob<-glob;l$glob1<-glob1;l$sp<-sp;l$w<-w
  }
  return(l)
}

# z1<- grid.clim.NNU(scores.clim12,scores.clim1,scores.sp1,R)
# glob <- scores.clim12
# glob1<-scores.clim1
# sp<-scores.sp1
# 
# th.sp=0
# th.env=0

##written by Henry, to get raw z values, NOT scaled from 0-1
grid.clim.NNU<-function(glob,glob1,sp,R,th.sp=0,th.env=0){
  
  
  l<-list()
  glob<-as.matrix(glob);glob1<-as.matrix(glob1);sp<-as.matrix(sp)
  if (ncol(glob)>2) stop("cannot calculate overlap with more than two axes")
  
  if(ncol(glob)==1){ 											#if scores in one dimension (e.g. LDA,SDM predictions,...)
    xmax<-max(glob[,1])
    xmin<-min(glob[,1])
    sp.dens<-density(sp[,1],kernel="gaussian",from=xmin,to=xmax,n=R,cut=0) 		# calculate the density of occurrences in a vector of R pixels along the score gradient
    # using a gaussian kernel density function, with R bins.
    glob1.dens<-density(glob1[,1],kernel="gaussian",from=xmin,to=xmax,n=R,cut=0)	# calculate the density of environments in glob1
    x<-sp.dens$x 											# breaks on score gradient
    z<-sp.dens$y*nrow(sp)/sum(sp.dens$y) 							# rescale density to the number of occurrences in sp
    # number of occurrence/pixel
    Z<-glob1.dens$y*nrow(glob)/sum(glob1.dens$y) 						# rescale density to the number of sites in glob1
    glob1r<-count(x,glob1);th.env<-min(Z[which(glob1r>0)]);glob1rm<-which(Z<th.env)
    spr<-count(x,sp);th.sp<-min(z[which(spr>0)]);sprm<-which(z<th.sp)
    z[sprm]<-0 										# remove infinitesimally small number generated by kernel density function
    Z[glob1rm]<-0 										# remove infinitesimally small number generated by kernel density function
    
    z.uncor<-z/max(z)											# rescale between [0:1] for comparison with other species
    z<-z/Z												# correct for environment prevalence
    z[is.na(z)]<-0 											# remove n/0 situations
    z[z=="Inf"]<-0 											# remove 0/0 situations
    z.cor<-z/max(z)											# rescale between [0:1] for comparison with other species
    w<-z
    w[w>0]<-1
    l$x<-x;l$y<-y;l$z<-z;l$z.uncor<-z.uncor;l$z.cor<-z.cor;l$Z<-Z;l$glob<-glob;l$glob1<-glob1;l$sp<-sp;l$w<-w
  }
  
  if(ncol(glob)==2){ #if scores in two dimensions (e.g. PCA)
    
    
    library(adehabitatHR)
    library(adehabitatLT)
    library(adehabitatMA)
    xmin<-min(glob[,1]);xmax<-max(glob[,1]);ymin<-min(glob[,2]);ymax<-max(glob[,2])			# data preparation
    glob1r<-data.frame(cbind((glob1[,1]-xmin)/abs(xmax-xmin),(glob1[,2]-ymin)/abs(ymax-ymin)))	# data preparation
    spr<-data.frame(cbind((sp[,1]-xmin)/abs(xmax-xmin),(sp[,2]-ymin)/abs(ymax-ymin))) 			# data preparation
    mask<-adehabitatMA::ascgen(SpatialPoints(cbind((1:R)/R,(1:R)/R)),nrcol=R,count=F)								# data preparation
    sp.dens<-adehabitatHR::kernelUD(SpatialPoints(spr[,1:2]),h = "href", grid=mask,kern="bivnorm")					# calculate the density of occurrences in a grid of RxR pixels along the score gradients
    
    # using a gaussian kernel density function, with RxR bins.
    #need to convert to spixdf but default output is estUD not estUDm. Convert in two stages
    sp.dens<-asc2spixdf(sp.dens$UD)							# data manipulation
    
    sp.dummy <- list()
    sp.dummy$var <- sp.dens                             #basically just build a list here
    class(sp.dummy) <- "estUDm"              #set the class attribute
    str(sp.dummy)
    sp.dens <- estUDm2spixdf(sp.dummy[[1]]$ud)
    length(sp.dens$ud)
    
    
    spr <- data.frame(cbind((sp[, 1] - xmin)/abs(xmax - xmin), 
                            (sp[, 2] - ymin)/abs(ymax - ymin)))
    mask <- adehabitatMA::ascgen(SpatialPoints(cbind((1:R)/R, (1:R)/R)), 
                                 nrcol = R - 2, count = FALSE)
    sp.dens <- adehabitatHR::kernelUD(SpatialPoints(spr[, 1:2]), h = "href", 
                                      grid = mask, kern = "bivnorm")
    
    sp.dens <- raster(matrix(sp.dens$ud, nrow=R),xmn = xmin, xmx = xmax, ymn = ymin, 
                      ymx = ymax)
    
    glob1.dens <- kernelUD(SpatialPoints(glob1r[, 1:2]), 
                           grid = mask, kern = "bivnorm")
    glob1.dens <- raster(xmn = xmin, xmx = xmax, ymn = ymin, 
                         ymx = ymax, matrix(glob1.dens$ud, nrow = R))
    
    
    
    #sp.dens$var[sp.dens$var>0 & sp.dens$var<1]<-0
    glob1.dens<-adehabitatHR::kernelUD(SpatialPoints(glob1r[,1:2]),grid=mask,kern="bivnorm")
    #glob1.dens<-asc2spixdf(glob1.dens[[1]]$UD)
    #glob1.dens$var[glob1.dens$var<1 & glob1.dens$var>0]<-0
    x<-seq(from=min(glob[,1]),to=max(glob[,1]),length.out=R)				# breaks on score gradient 1
    y<-seq(from=min(glob[,2]),to=max(glob[,2]),length.out=R)				# breaks on score gradient 2
    ###***### Here can see which gridcell ends up in.
    z<-matrix(sp.dens$var*nrow(sp)/sum(sp.dens$var),nrow=R,ncol=R,byrow=F) 			#rescale density to the number of occurrences in sp
    Z<-matrix(glob1.dens$var*nrow(glob1)/sum(glob1.dens$var),nrow=R,ncol=R,byrow=F) 	#rescale density to the number of sites in glob1
    spr<-pts2img(sp,cbind(x,y))
    glob1r<-pts2img(glob1,cbind(x,y))
    z.th<-quantile(as.vector(z[which(spr==1)]),th.sp)
    Z.th<-quantile(as.vector(Z[which(glob1r[]==1)]),th.env)  
    z[z<z.th]<-0 					#z[z<max(z)/(nrow(sp)/6)]<-0 or z[z<(nrow(sp)^(1/6)*0.005)]<-0 				# remove infinitesimally small number generated by kernel density function
    Z[Z<Z.th]<-0     # [Z<(nrow(glob1)^(1/6)*0.005)]
    
    z.raw<-z/Z
    #HH- the following rotations are need to match everything together, matrices, raw data and rasters
    z.raw<-t(z.raw)
    z.rawR <- raster(z.raw,xmn = xmin, xmx = xmax, ymn = ymin, 
                     ymx = ymax)
    z.rawR<-flip(z.rawR,direction='y')
    Z_clim_raw<-t(Z)
    
    Z.clim <- raster(Z_clim_raw,xmn = xmin, xmx = xmax, ymn = ymin, 
                     ymx = ymax)
    
    Z.clim<-flip(Z.clim,direction='y')
    
    
    z.uncor<-z/max(z)	# rescale between [0:1] for comparison with other species  
    z.uncorR<-t(z.uncor)
    z.uncorR<-raster(z.uncorR,xmn = xmin, xmx = xmax, ymn = ymin, 
                     ymx = ymax)
    z.uncorR<-flip(z.uncorR,direction='y')
    
    
    w<-z.uncorR 											# remove infinitesimally small number generated by kernel density function
    w[w>0]<-1
    z<-z/Z												# correct for environment prevalence
    z[is.na(z)]<-0											# remove n/0 situations
    z[z=="Inf"]<-0            	# remove n/0 situations
    z.cor<-z/max(z)											# rescale between [0:1] for comparison with other species
    z.corR<-t(z.cor)
    z.corR<-raster(z.corR,xmn = xmin, xmx = xmax, ymn = ymin, 
                   ymx = ymax)
    z.corR<-flip(z.corR,direction='y')
    
    l$x<-x;l$y<-y;l$z.uncor<-z.uncorR;l$z.cor<-z.corR;l$Z<-Z.clim;l$glob<-glob;l$glob1<-glob1;l$sp<-sp;l$w<-w;l$z.raw<-z.rawR;l$z.rawR<-z.raw;l$z.uncorR<-z.uncor;l$Z.clim<-Z
  }
  return(l)
}


# z1<- grid.clim.NNU(scores.clim12,scores.clim1,scores.sp1,R)
# glob <- scores.clim12
# glob1<-scores.clim1
# sp<-scores.sp1
# 
# th.sp=0
# th.env=0
# geomask=NULL

#this is the original version of grid.clim.NNU, kept for comparisons and checking old results
grid.clim.NNU2<-function (glob, glob1, sp, R, th.sp = 0, th.env = 0, geomask = NULL) 
{
  glob <- as.matrix(glob)
  glob1 <- as.matrix(glob1)
  sp <- as.matrix(sp)
  l <- list()
  if (ncol(glob) > 2) 
    stop("cannot calculate overlap with more than two axes")
  if (ncol(glob) == 1) {
    xmax <- max(glob[, 1])
    xmin <- min(glob[, 1])
    x <- seq(from = min(glob[, 1]), to = max(glob[, 1]), 
             length.out = R)
    sp.dens <- density(sp[, 1], kernel = "gaussian", from = xmin, 
                       to = xmax, n = R, cut = 0)
    glob1.dens <- density(glob1[, 1], kernel = "gaussian", 
                          from = xmin, to = xmax, n = R, cut = 0)
    z <- sp.dens$y * nrow(sp)/sum(sp.dens$y)
    Z <- glob1.dens$y * nrow(glob)/sum(glob1.dens$y)
    glob1r <- sapply(glob1, findInterval, glob1.dens$x)
    th.env <- quantile(glob1.dens$y[glob1r], th.env)
    glob1rm <- which(Z < th.env)
    spr <- sapply(sp, findInterval, sp.dens$x)
    th.sp <- quantile(sp.dens$y[spr], th.sp)
    sprm <- which(z < th.sp)
    z[sprm] <- 0
    Z[glob1rm] <- 0
    z.uncor <- z/max(z)
    z.cor <- z/Z
    z.cor[is.na(z.cor)] <- 0
    z.cor[z.cor == "Inf"] <- 0
    z.cor <- z.cor/max(z.cor)
    w <- z.uncor
    w[w > 0] <- 1
    l$x <- x
    l$z <- z
    l$z.uncor <- z.uncor
    l$z.cor <- z.cor
    l$Z <- Z
    l$glob <- glob
    l$glob1 <- glob1
    l$sp <- sp
    l$w <- w
  }
  if (ncol(glob) == 2) {
    xmin <- min(glob[, 1])
    xmax <- max(glob[, 1])
    ymin <- min(glob[, 2])
    ymax <- max(glob[, 2])
    glob1r <- data.frame(cbind((glob1[, 1] - xmin)/abs(xmax - 
                                                         xmin), (glob1[, 2] - ymin)/abs(ymax - ymin)))
    
    spr <- data.frame(cbind((sp[, 1] - xmin)/abs(xmax - xmin), 
                            (sp[, 2] - ymin)/abs(ymax - ymin)))
    mask <- adehabitatMA::ascgen(SpatialPoints(cbind((1:R)/R, (1:R)/R)), 
                                 nrcol = R - 2, count = FALSE)
    sp.dens <- adehabitatHR::kernelUD(SpatialPoints(spr[, 1:2]), h = "href", 
                                      grid = mask, kern = "bivnorm")
    
    sp.dens <- raster(matrix(sp.dens$ud, nrow=R),xmn = xmin, xmx = xmax, ymn = ymin, 
                      ymx = ymax)
    
    glob1.dens <- kernelUD(SpatialPoints(glob1r[, 1:2]), 
                           grid = mask, kern = "bivnorm")
    glob1.dens <- raster(xmn = xmin, xmx = xmax, ymn = ymin, 
                         ymx = ymax, matrix(glob1.dens$ud, nrow = R))
    x <- seq(from = min(glob[, 1]), to = max(glob[, 1]), 
             length.out = R)
    y <- seq(from = min(glob[, 2]), to = max(glob[, 2]), 
             length.out = R)
    glob1r <- extract(glob1.dens, glob1)
    Z.th <- quantile(glob1r, th.env)
    glob1.dens[glob1.dens < Z.th] <- 0
    if (!is.null(geomask)) {
      proj4string(geomask) <- NA
      glob1.dens <- mask(glob1.dens, geomask, updatevalue = 0)
    }
    Z <- glob1.dens * nrow(glob1)/cellStats(glob1.dens, "sum")
    spr <- extract(sp.dens, sp)
    z.th <- quantile(spr, th.sp)
    sp.dens[Z == 0] <- 0
    sp.dens[sp.dens < z.th] <- 0
    if (!is.null(geomask)) {
      sp.dens <- mask(sp.dens, geomask, updatevalue = 0)
    }
    z <- sp.dens * nrow(sp)/cellStats(sp.dens, "sum")
    
    z.raw<-z/Z
    z.uncor <- z/cellStats(z, "max")
    w <- z.uncor
    w[w > 0] <- 1
    z.cor <- z/Z
    
    
    
    l$x<-x;l$y<-y;l$z.uncor<-z.uncor;l$z.cor<-z.cor;l$Z<-Z;l$glob<-glob;l$glob1<-glob1;l$sp<-sp;l$w<-w;l$z.raw<-z.raw;l$zz<-z;
  }
  return(l)
}


##################################################################################################

niche.overlap<-function(z1,z2,cor){ 
  
  # z1 = species 1 occurrence density grid created by grid.clim
  # z2 = species 2 occurrence density grid created by grid.clim
  # cor=T correct occurrence densities of each species by the prevalence of the environments in their range
  
  l<-list()
  
  if(cor==F){		
    p1<-z1$z.uncor/sum(z1$z.uncor) # rescale occurence densities so that the sum of densities is the same for both species
    p2<-z2$z.uncor/sum(z2$z.uncor) # rescale occurence densities so that the sum of densities is the same for both species
  }
  
  if(cor==T){
    p1<-z1$z.cor/sum(z1$z.cor)	# rescale occurence densities so that the sum of densities is the same for both species
    p2<-z2$z.cor/sum(z2$z.cor)	# rescale occurence densities so that the sum of densities is the same for both species
  }
  
  D <-1-(0.5*(sum(abs(p1-p2))))				# overlap metric D
  I <-1-(0.5*(sqrt(sum((sqrt(p1)-sqrt(p2))^2))))	# overlap metric I
  l$D<-D
  l$I<-I
  return(l)
}

##################################################################################################

plot.niche<-function(z,title,name.axis1="PC1",name.axis2="PC2",cor=F){
  
  if(is.null(z$y)){
    R<-length(z$x)
    x<-z$x
    xx<-sort(rep(1:length(x),2))
    
    
    if(cor==F)y1<-z$z.uncor/max(z$z.uncor)
    if(cor==T)y1<-z$z.cor/max(z$z.cor)
    
    Y1<-z$Z/max(z$Z)
    yy1<-sort(rep(1:length(y1),2))[-c(1:2,length(y1)*2)]
    YY1<-sort(rep(1:length(Y1),2))[-c(1:2,length(Y1)*2)]
    
    plot(x,y1,type="n",xlab=name.axis1,ylab="density of occurrence")
    polygon(x[xx],c(0,y1[yy1],0,0),col="grey")
    lines(x[xx],c(0,Y1[YY1],0,0))
  }
  
  if(!is.null(z$y)){
    if(cor==F)image(z$x,z$y,as.matrix(z$z.uncor),col = gray(100:0 / 100),zlim=c(0.000001,cellStats(z$z.uncor, stat='max')),xlab=name.axis1,ylab=name.axis2)
    if(cor==T)image(z$x,z$y,as.matrix(z$z.cor),col = gray(100:0 / 100),zlim=c(0.000001,cellStats(z$z.cor, stat='max')),xlab=name.axis1,ylab=name.axis2)
    contour(z$x,z$y,as.matrix(z$Z),add=T,levels=quantile(z$Z[z$Z>0],c(0,0.25)),drawlabels=F,lty=c(1,2))
  }
  title(title)
}

plot.contrib<-function(contrib,eigen){
  
  if(ncol(contrib)==1){
    h<-c(unlist(contrib))
    n<-row.names(contrib)
    barplot(h,space=0,names.arg=n)
    title(main="variable contribution")
  }
  if(ncol(contrib)==2){
    s.corcircle(contrib[,1:2]/max(abs(contrib[,1:2])),grid = F)
    title(main="Correlation circle", line=2)
    title(sub=paste("Axis 1 = ",round(eigen[1]/sum(eigen)*100,2),"%",", axis 2 = ",round(eigen[2]/sum(eigen)*100,2),"%"))
  }
}

plot.overlap.test<-function (x,type,title) {
  if(type=="D") {
    obs <- x$obs$D
    sim <- x$sim$D
    p<-x$p.D
  }
  if(type=="I") {
    obs <- x$obs$I
    sim <- x$sim$I
    p<-x$p.I
  }
  r0 <- c(sim, obs)
  l0 <- max(sim) - min(sim)
  w0 <- l0/(log(length(sim), base = 2) + 1)
  xlim0 <- range(r0) + c(-w0, w0)
  h0 <- hist(sim, plot = FALSE, nclass = 10)
  y0 <- max(h0$counts)
  hist(sim, plot = TRUE, nclass = 10, xlim = xlim0, col = grey(0.8), main= title, xlab=type,sub = paste("p.value = ",round(p,5)))
  lines(c(obs, obs), c(y0/2, 0),col="red")
  points(obs, y0/2, pch = 18, cex = 2,col="red")
  invisible()
}

# plot.niche.dyn<-function(z1,z2,quant=0,title,interest=1,colz1="#00FF0050",colz2="#FF000050",colinter="#0000FF50",colZ1="green3",colZ2="red3",name.axis1="PC1",name.axis2="PC2"){ ## Green is native and red is invasive, in my normal scheme of things

plot.niche.dyn<-function(z1,z2,quant=0,title,interest=1,colz1=ntv.col,colz2=usa.col,colinter=overlap.col,colZ1=ntv.col.cont,colZ2=usa.col.cont,name.axis1="PC1",name.axis2="PC2", yl=c(min(z1$y,z2$y),max(z1$y,z2$y))){ ## Blue is native and Yellow is invasive, in my normal scheme of things
  
  if(is.null(z1$y)){
    R<-length(z1$x)
    x<-z1$x
    xx<-sort(rep(1:length(x),2))
    
    y1<-z1$z.uncor/max(z1$z.uncor)
    #	if(cor==T)y1<-z$z.cor/max(z$z.cor)
    Y1<-z1$Z/max(z1$Z)
    if (quant>0){
      Y1.quant<-quantile(z1$Z[which(z1$Z>0)],probs=seq(0,1,quant))[2] / max(z1$Z)
    }else{
      Y1.quant<-0
    }
    Y1.quant<-Y1-Y1.quant; Y1.quant[Y1.quant<0]<-0
    yy1<-sort(rep(1:length(y1),2))[-c(1:2,length(y1)*2)]
    YY1<-sort(rep(1:length(Y1),2))[-c(1:2,length(Y1)*2)]
    
    y2<-z2$z.uncor/max(z2$z.uncor)
    #	if(cor==T)y1<-z$z.cor/max(z$z.cor)
    Y2<-z2$Z/max(z2$Z)
    if (quant>0){
      Y2.quant<-quantile(z2$Z[which(z2$Z>0)],probs=seq(0,1,quant))[2] / max(z2$Z)
    }else{
      Y2.quant=0
    }
    Y2.quant<-Y2-Y2.quant; Y2.quant[Y2.quant<0]<-0
    yy2<-sort(rep(1:length(y2),2))[-c(1:2,length(y2)*2)]
    YY2<-sort(rep(1:length(Y2),2))[-c(1:2,length(Y2)*2)]
    
    plot(x,y1,type="n",xlab=name.axis1,ylab="density of occurrence")
    polygon(x[xx],c(0,y1[yy1],0,0),col=colz1,border=0)
    polygon(x[xx],c(0,y2[yy2],0,0),col=colz2,border=0)
    polygon(x[xx],c(0,apply(cbind(y2[yy2],y1[yy1]),1,min,na.exclude=T),0,0),col=colinter,border=0)
    lines(x[xx],c(0,Y2.quant[YY2],0,0),col=colZ2,lty="dashed")
    lines(x[xx],c(0,Y1.quant[YY1],0,0),col=colZ1,lty="dashed")
    lines(x[xx],c(0,Y2[YY2],0,0),col=colZ2)
    lines(x[xx],c(0,Y1[YY1],0,0),col=colZ1)
    segments(x0=0,y0=0,x1=max(x[xx]),y1=0,col="white")
    segments(x0=0,y0=0,x1=0,y1=1,col="white")
    
    seg.cat<-function(inter,cat,col.unf,col.exp,col.stab){
      if (inter[3]==0){my.col=0}
      if (inter[3]==1){my.col=col.unf}
      if (inter[3]==2){my.col=col.stab}
      if (inter[3]==-1){my.col=col.exp}
      segments(x0= inter[1],y0=-0.01,y1=-0.01,x1=inter[2],col=my.col,lwd=4,lty=2)
    }
    cat<-dynamic.index(z1,z2,intersection=quant)$dyn
    inter<-cbind(z1$x[-length(z1$x)],z1$x[-1],cat[-1])
    apply(inter,1,seg.cat,col.unf="#00FF0050",col.exp="#FF000050",col.stab="#0000FF50")
    
  }
  if(!is.null(z1$y)){
    
    z<-z1$w+2*z2$w
    if(interest==1){
      image(z1$x,z1$y,as.matrix(z1$z.uncor),col = gray(100:0 / 100),zlim=c(0.00001,cellStats(z1$z.uncor, stat='max')),xlab=name.axis1,ylab=name.axis2,ylim=yl)
      image(z1$x,z1$y,as.matrix(z),col = c("#FFFFFF00",colz1,colz2,colinter),add=T)
    }
    if(interest==2){
      image(z2$x,z2$y,as.matrix(z2$z.uncor),col = gray(100:0 / 100),zlim=c(0.00001,cellStats(z2$z.uncor, stat='max')),xlab=name.axis1,ylab=name.axis2,ylim=yl)
      image(z2$x,z2$y,as.matrix(z),col = c("#FFFFFF00",colz1,colz2,colinter),add=T )
    }
    title(title)
    contour(z1$x,z1$y,as.matrix(z1$Z),add=T,levels=quantile(z1$Z[z1$Z>0],c(0,quant)),drawlabels=F,lty=c(1,2),col=colZ1)
    contour(z2$x,z2$y,as.matrix(z2$Z),add=T,levels=quantile(z2$Z[z2$Z>0],c(0,quant)),drawlabels=F,lty=c(1,2),col=colZ2)
  }
}


pts2img <- function(pts,extent){
  img <- matrix(0,nrow=nrow(extent),ncol=nrow(extent))
  x<-findInterval(pts[,1],extent[,1])
  y<-findInterval(pts[,2],extent[,2])
  xy<-cbind(x,y)
  img[xy]<-1
  return(img)
}

fun.arrows<-function(sp1,sp2,clim1,clim2,col="red"){
  
  if (ncol(as.matrix(sp1))==2){
    arrows(median(sp1[,1]),median(sp1[,2]),median(sp2[,1]),median(sp2[,2]),col="red",lwd=2,length=0.1)
    arrows(median(clim1[,1]),median(clim1[,2]),median(clim2[,1]),median(clim2[,2]),lty="11",col=col,lwd=2,length=0.1)
  }else{
    arrows(median(sp1),0.025,median(sp2),0.025,col="red",lwd=2,length=0.1)
    arrows(median(clim1),-0.025,median(clim2),-0.025,lty="11",col=col,lwd=2,length=0.1)
  }
}

count<-function(interval,values){
  count<-c()
  for (i in 1:(length(interval)-1)){
    count<-c(count,length(which(values>=interval[i] & values <interval[i+1])))
    if (i== length(interval)-1 ){count[i]<-length(which(values>=interval[i] & values <=interval[i+1]))}
  }
  return(count)
}

##################################################################################################
### Rewritten by Regan
dynamic.index<-function(z1,z2,thresh,th.sp) {
  
  
  glob1<-z1$Z              # Native environmental extent densities
  glob2<-z2$Z              # Invaded environmental extent densities
  if (thresh=='xxx'){
    w1<-z1$w         # Environmental native distribution in all climate space
    w2<-z2$w         # Environmental invasive distribution in all climate space
    glob.pot <- glob2 # Climate space available in USA
    glob.pot[glob.pot[]>0]<-1 
    
  } else {
    quant.val<-quantile(glob1[glob1>0],probs=seq(0,1,0.01))[thresh+1]     # threshold do delimit native environmental mask. Exclude climate below the given percentile
    glob1[glob1[]<quant.val]<-0; glob1[glob1[]>=quant.val]<-1                #  native environmental mask
    quant.val<-quantile(glob2[glob2>0],probs=seq(0,1,0.01))[thresh+1]      # threshold do delimit invaded environmental mask
    glob2[glob2[]<quant.val]<-0;glob2[glob2[]>=quant.val]<-1                #  invaded environmental mask                                                                 
    glob <- glob.pot <- glob1*glob2     # delimitation of the intersection between the native and invaded extents    
    w1<-z1$w*glob         # Environmental native distribution at the intersection 
    w2<-z2$w*glob         # Environmental invasive distribution at the intersection 
  }  
  
  z.exp.cat<-(w1+2*w2)/2; z.exp.cat[z.exp.cat!=1]<-0             #categorizing expansion pixels. Treats cells as occupied or not. A value of 1 from the first equation means that the cell is not occupied in Europe (w1+2=2), and occupied in the USA (w2=1), therefore (w1+2*w2)/2 = 2
  z.stable.cat<-(w1+2*w2)/3;z.stable.cat[z.stable.cat!=1]<-0    #categorizing stable pixels
  z.res.cat<-w1+2*w2;z.res.cat[z.res.cat!=1]<-0              #categorizing restriction pixels
  obs.exp<-z2$z.uncor*z.exp.cat                             #Correct for density of USA occupancy points
  obs.stab<-z2$z.uncor*z.stable.cat                         #Correct for density of USA occupancy points
  obs.res<-z1$z.uncor*z.res.cat						  #Correct for density of European occupancy points
  
  dyn<-(-1*z.exp.cat)+(2*z.stable.cat)+z.res.cat;    # draw matrix (100*100) with 3 categories of niche dynamic
  expansion.index.w<-cellStats(obs.exp,stat='sum')/cellStats(obs.stab+obs.exp,stat='sum'); # expansion as a proportion of the invasive range
  stability.index.w<-cellStats(obs.stab,stat='sum')/cellStats(obs.stab+obs.exp,stat='sum') # stability as a proportion of the invasive range
  restriction.index.w<-cellStats(obs.res,stat='sum')/cellStats(obs.res+(z.stable.cat*z1$z.uncor),stat='sum') #unfilling as a proportion of the native range
  total.occupancy <- cellStats(z2$z.uncor*glob.pot,stat='sum')
  
  ##### Potential Expansion:
  z.exp.cat.pot.x <- z.stable.cat + z.res.cat #z.exp.cat + 
  z.exp.cat.pot <- z.exp.cat.pot.x
  z.exp.cat.pot[z.exp.cat.pot.x==1]<-0     
  z.exp.cat.pot[z.exp.cat.pot.x==0]<-1  ## Probably a much more straightforward way to do this! But basically identifies all cells with no expansion, stability or unfilling 
  z.exp.cat.pot <- z.exp.cat.pot*glob.pot ## Control for analogue climate space if necessary
  exp.pot.cells <- cellStats(z.exp.cat.pot,stat='sum')
  exp.obs.cells <- cellStats(z.exp.cat,stat='sum')
  
  part<-list();part$dyn<-dyn
  part$dynamic.index.w<-c(round(c(expansion.index.w,stability.index.w,restriction.index.w,total.occupancy),5), exp.obs.cells, exp.pot.cells)
  names(part$dynamic.index.w)<-c("expansion","stability","unfilling", "total occupancy", "expansion observed cells", "expansion potential cells")
  return(part)
}

#################################################################################################
### Rewritten by Regan
dynamic.index.nnd<-function(z1,z2,thresh) {
  
  glob1<-z1$Z              # Native environmental extent densities
  glob2<-z2$Z              # Invaded environmental extent densities
  if (thresh=='xxx'){
    w1<-z1$w         # Environmental native distribution in all climate space
    w2<-z2$w         # Environmental invaded distribution in all climate space
    glob.pot <- glob2 # Climate space available in Europe
    glob.pot[glob.pot[]>0]<-1 
    
  } else {
    quant.val<-quantile(glob1[glob1>0],probs=seq(0,1,0.01))[thresh+1]     # threshold do delimit native environmental mask. Exclude climate below the given percentile
    glob1[glob1[]<quant.val]<-0; glob1[glob1[]>=quant.val]<-1                #  native environmental mask
    quant.val<-quantile(glob2[glob2>0],probs=seq(0,1,0.01))[thresh+1]      # threshold do delimit invaded environmental mask
    glob2[glob2[]<quant.val]<-0;glob2[glob2[]>=quant.val]<-1                #  invaded environmental mask                                                                 
    glob <- glob.pot <- glob1*glob2 # delimitation of the intersection between the native and invaded extents    
    w1<-z1$w*glob         # Environmental invasive distribution at the intersection 
    w2<-z2$w*glob         # Environmental native distribution at the intersection 
  }
  
  
  z.exp.cat<-(w1+2*w2)/2; z.exp.cat[z.exp.cat!=1]<-0             #categorizing expansion pixels. Treats cells as occupied or not. A value of 1 from the first equation means that the cell is not occupied in Europe (w1+2=2), and occupied in the USA (w2=1), therefore (w1+2*w2)/2 = 2
  z.stable.cat<-(w1+2*w2)/3;z.stable.cat[z.stable.cat!=1]<-0    #categorizing stable pixels
  z.res.cat<-w1+2*w2;z.res.cat[z.res.cat!=1]<-0              #categorizing restriction pixels
  
  obs.exp<-z2$z.uncor*z.exp.cat                             #Correct for density of European occupancy points
  obs.stab<-z1$z.uncor*z.stable.cat                         #Correct for density of European occupancy points
  obs.res<-z1$z.uncor*z.res.cat    					  #Correct for density of USA occupancy points
  
  obs.stab.natur<-z2$z.uncor*z.stable.cat                         #Correct for density of European occupancy points
  
  
  dyn<-(-1*z.exp.cat)+(2*z.stable.cat)+z.res.cat;    # draw matrix (100*100) with 3 categories of niche dynamic
  nnd.propn<-sum(as.matrix(obs.exp))/sum(as.matrix(obs.stab)+as.matrix(obs.res)); # expansion as a proportion of the native range
  nnd <- sum(as.matrix(obs.exp))
  
  nnu.propn<-sum(as.matrix(obs.res))/sum(as.matrix(obs.stab.natur)+as.matrix(obs.exp)); # unfilling as a proportion of the naturalised range
  nnu <- sum(as.matrix(obs.res))
  
  exp.obs.cells <- sum(as.matrix(z.exp.cat))
  exp.obs.cells.propn <- sum(as.matrix(z.exp.cat)) / (sum(as.matrix(z.stable.cat)) + sum(as.matrix(z.res.cat)))# expansion as a proportion of the native range
  
  res.obs.cells <- sum(as.matrix(z.res.cat))
  res.obs.cells.propn <- sum(as.matrix(z.res.cat)) / (sum(as.matrix(z.stable.cat)) + sum(as.matrix(z.exp.cat)))# expansion as a proportion of the native range
  
  
  part<-list();part$dyn<-dyn
  part$nnd<-round(c(nnd,nnd.propn, exp.obs.cells, exp.obs.cells.propn,nnu,nnu.propn,res.obs.cells,res.obs.cells.propn),3)
  names(part$nnd) <- c('nnd','nnd.propn', 'nnd.observed.cells','nnd.observed.cells.propn','nnu','nnu.propn','nnu.observed.cells','nnu.observed.cells.propn')
  return(part)
}
